<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual de Implementación: Clase JsonSqlHelper Avanzada</title>
    <style>
        :root {
            --primary-color: #004a7c;
            --primary-dark-color: #003b63;
            --border-color: #dee2e6;
            --background-color: #f8f9fa;
            --text-color: #212529;
            --code-bg-color: #f6f8fa;
            --code-border-color: #d0d7de;
            --success-color: #28a745;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.7;
            color: var(--text-color);
            background-color: #ffffff;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1024px;
            margin: 20px auto;
            padding: 15px 30px 30px 30px;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.07);
        }

        h1, h2, h3 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-dark-color);
            padding-bottom: 12px;
            margin-top: 40px;
            font-weight: 600;
        }

        h1 { font-size: 2.4em; }
        h2 { font-size: 1.9em; }
        h3 { font-size: 1.5em; border-bottom: 1px solid var(--border-color); }

        .code-container {
            position: relative;
            margin: 20px 0;
        }

        pre {
            background-color: var(--code-bg-color);
            border: 1px solid var(--code-border-color);
            border-radius: 6px;
            padding: 20px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: "Consolas", "SFMono-Regular", "Menlo", "Monaco", "Liberation Mono", "Courier New", monospace;
            font-size: 14px;
            overflow-x: auto;
            line-height: 1.5;
        }
        
        code {
             font-family: "Consolas", "SFMono-Regular", "Menlo", "Monaco", "Liberation Mono", "Courier New", monospace;
        }

        .copy-button {
            position: absolute;
            top: 12px;
            right: 12px;
            background-color: #f6f8fa;
            border: 1px solid rgba(27,31,36,0.15);
            border-radius: 6px;
            color: #24292f;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            font-weight: 500;
            padding: 5px 12px;
            transition: background-color 0.2s cubic-bezier(0.3, 0, 0.5, 1);
            user-select: none;
        }

        .copy-button:hover {
            background-color: #f3f4f6;
            border-color: rgba(27,31,36,0.35);
        }
        
        .copy-button.copied {
            background-color: var(--success-color);
            color: white;
            border-color: #208339;
        }

        .note, .warning {
            border-left: 6px solid;
            padding: 15px 20px;
            margin: 25px 0;
            border-radius: 4px;
        }

        .note {
            background-color: #e7f3fe;
            border-color: #2196F3;
        }

        .warning {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Manual de Implementación: Clase <code>JsonSqlHelper</code> Avanzada</h1>
        <p>Esta clase de utilidad para <strong>Visual Basic .NET</strong> ha sido generada para actuar como una potente herramienta de creación de fragmentos T-SQL. Simplifica drásticamente la manipulación y consulta de campos JSON en <strong>SQL Server 2017</strong> y <strong>2022</strong>, incorporando funcionalidades avanzadas como manejo de arrays, serialización de objetos, generación de cláusulas <code>WHERE</code> y operaciones de carga masiva.</p>

        <div class="warning">
            <strong>Prerrequisito:</strong> Esta clase depende de la librería <strong>Newtonsoft.Json</strong>. Debes instalarla en tu proyecto a través del gestor de paquetes NuGet: <br><code>Install-Package Newtonsoft.Json</code>
        </div>

        <h2>Código Fuente de la Clase (JsonSqlHelper.vb)</h2>
        <div class="code-container">
            <pre><code>
Imports Newtonsoft.Json
Imports System.Collections.Generic
Imports System.Dynamic
Imports System.Text
Imports System.Text.RegularExpressions

''' &lt;summary&gt;
''' Enumera las versiones de SQL Server soportadas para optimizar la generación de T-SQL.
''' &lt;/summary&gt;
Public Enum SqlServerVersion
    SQL2017
    SQL2022
End Enum

''' &lt;summary&gt;
''' Clase de utilidad avanzada para generar fragmentos de T-SQL para manipular campos JSON en SQL Server.
''' &lt;/summary&gt;
Public Class JsonSqlHelper

#Region "Propiedades"
    ''' &lt;summary&gt;
    ''' Obtiene o establece la versión de SQL Server de destino para optimizar las consultas.
    ''' El valor por defecto es SQL2017.
    ''' &lt;/summary&gt;
    Public Property SqlServerVersion As SqlServerVersion = SqlServerVersion.SQL2017

    ''' &lt;summary&gt;
    ''' Obtiene o establece el contenido del objeto JSON como una cadena.
    ''' &lt;/summary&gt;
    Public Property JsonContent As String = "{}"
#End Region

#Region "Serialización de Objetos"
    ''' &lt;summary&gt;
    ''' Serializa un objeto de VB.NET y establece su representación JSON en la propiedad JsonContent.
    ''' &lt;/summary&gt;
    ''' &lt;param name="obj"&gt;El objeto a serializar.&lt;/param&gt;
    Public Sub SetJsonContentFromObject(obj As Object)
        JsonContent = JsonConvert.SerializeObject(obj)
    End Sub
#End Region

#Region "Manipulación de Datos (UPDATE)"
    ''' &lt;summary&gt;
    ''' Genera el fragmento T-SQL para añadir, actualizar o añadir a un array en un campo JSON usando JSON_MODIFY.
    ''' &lt;/summary&gt;
    ''' &lt;param name="jsonFieldName"&gt;El nombre del campo de la tabla. Ejemplo: "DatosAdicionales"&lt;/param&gt;
    ''' &lt;param name="path"&gt;La expresión de ruta JSON. Para añadir a un array, usa "append $.arrayName". Ejemplo: "$.cliente.nombre"&lt;/param&gt;
    ''' &lt;param name="value"&gt;El valor a insertar/actualizar. Si es Nothing, se eliminará el atributo.&lt;/param&gt;
    ''' &lt;returns&gt;Una cadena con el fragmento T-SQL para una cláusula SET.&lt;/returns&gt;
    Public Function AddOrUpdateValue(jsonFieldName As String, path As String, value As Object) As String
        If value Is Nothing OrElse value Is DBNull.Value Then
            Return DeleteValue(jsonFieldName, path)
        End If

        Dim valueToUse As Object = value
        ' Si el valor es un objeto complejo (no un tipo primitivo), serializarlo a JSON
        If Not (TypeOf value Is String OrElse value.GetType().IsPrimitive OrElse TypeOf value Is Decimal OrElse TypeOf value Is DateTime) Then
            valueToUse = JsonConvert.SerializeObject(value)
            Return $"SET [{jsonFieldName}] = JSON_MODIFY([{jsonFieldName}], '{path}', JSON_QUERY('{valueToUse.ToString().Replace("'", "''")}'))"
        End If

        Dim formattedValue As String = FormatSqlValue(valueToUse)
        Return $"SET [{jsonFieldName}] = JSON_MODIFY([{jsonFieldName}], '{path}', {formattedValue})"
    End Function

    ''' &lt;summary&gt;
    ''' Genera el fragmento T-SQL para eliminar un atributo o un elemento de un array de un campo JSON.
    ''' &lt;/summary&gt;
    ''' &lt;param name="jsonFieldName"&gt;El nombre del campo de la tabla.&lt;/param&gt;
    ''' &lt;param name="path"&gt;La expresión de ruta JSON del atributo a eliminar (ej: "$.tags[2]").&lt;/param&gt;
    ''' &lt;returns&gt;Una cadena con el fragmento T-SQL para una cláusula SET.&lt;/returns&gt;
    Public Function DeleteValue(jsonFieldName As String, path As String) As String
        Return $"SET [{jsonFieldName}] = JSON_MODIFY([{jsonFieldName}], '{path}', NULL)"
    End Function
#End Region

#Region "Consulta de Datos (SELECT / WHERE)"
    ''' &lt;summary&gt;
    ''' Genera una cláusula WHERE para filtrar registros basados en un valor dentro del campo JSON.
    ''' &lt;/summary&gt;
    ''' &lt;param name="jsonFieldName"&gt;El nombre del campo de la tabla.&lt;/param&gt;
    ''' &lt;param name="path"&gt;La ruta JSON del atributo por el que filtrar.&lt;/param&gt;
    ''' &lt;param name="operator"&gt;El operador de comparación (ej: "=", "!=", "&gt;", "LIKE").&lt;/param&gt;
    ''' &lt;param name="value"&gt;El valor a comparar.&lt;/param&gt;
    ''' &lt;returns&gt;Una cadena de condición para una cláusula WHERE.&lt;/returns&gt;
    Public Function GenerateWhereClause(jsonFieldName As String, path As String, operator As String, value As Object) As String
        Dim formattedValue As String = FormatSqlValue(value)
        ' Optimización para SQL Server 2022+: JSON_PATH_EXISTS es más eficiente para comprobar existencias.
        If SqlServerVersion = SqlServerVersion.SQL2022 AndAlso operator.Trim().ToUpper() = "EXISTS" Then
            Return $"JSON_PATH_EXISTS([{jsonFieldName}], '{path}') = 1"
        End If
        Return $"JSON_VALUE([{jsonFieldName}], '{path}') {operator} {formattedValue}"
    End Function

    ''' &lt;summary&gt;
    ''' Genera una cadena de columnas para un SELECT, extrayendo y convirtiendo tipos de datos de un campo JSON.
    ''' &lt;/summary&gt;
    ''' &lt;param name="jsonFieldName"&gt;El nombre del campo de la tabla.&lt;/param&gt;
    ''' &lt;param name="attributes"&gt;Un diccionario donde la Clave es la ruta JSON y el Valor es el tipo de dato SQL (ej: "NVARCHAR(100)", "INT", "BIT").&lt;/param&gt;
    ''' &lt;returns&gt;Una cadena de columnas separadas por comas para usar en un SELECT.&lt;/returns&gt;
    Public Function GetJsonAttributesForSelect(jsonFieldName As String, attributes As Dictionary(Of String, String)) As String
        If attributes Is Nothing OrElse attributes.Count = 0 Then Return ""

        Dim sb As New StringBuilder()
        Dim aliasCounts As New Dictionary(Of String, Integer)()

        For Each attr As KeyValuePair(Of String, String) In attributes
            ' Generar un alias legible a partir de la ruta
            Dim aliasBase As String = String.Join("_", attr.Key.Split("."c, "$"c, "["c, "]"c).Where(Function(s) Not String.IsNullOrEmpty(s)))
            Dim finalAlias As String = aliasBase
            If aliasCounts.ContainsKey(aliasBase) Then
                aliasCounts(aliasBase) += 1
                finalAlias = $"{aliasBase}{aliasCounts(aliasBase)}"
            Else
                aliasCounts(aliasBase) = 1
            End If
            
            sb.Append($"TRY_CAST(JSON_VALUE([{jsonFieldName}], '{attr.Key}') AS {attr.Value}) AS {finalAlias}, ")
        Next

        If sb.Length > 0 Then sb.Length -= 2
        Return sb.ToString()
    End Function

    ''' &lt;summary&gt;
    ''' Genera un fragmento T-SQL para usar con CROSS APPLY OPENJSON, permitiendo consultas dinámicas.
    ''' &lt;/summary&gt;
    ''' &lt;param name="jsonFieldName"&gt;El nombre del campo de la tabla que contiene el JSON.&lt;/param&gt;
    ''' &lt;returns&gt;Una cadena para usar en la cláusula FROM.&lt;/returns&gt;
    Public Function GetDynamicJsonAttributesForSelect(jsonFieldName As String) As String
        Return $"CROSS APPLY OPENJSON([{jsonFieldName}])"
    End Function
#End Region

#Region "Inserción y Carga Masiva"
    ''' &lt;summary&gt;
    ''' Devuelve el contenido de la propiedad JsonContent formateado para una instrucción SQL INSERT o UPDATE.
    ''' &lt;/summary&gt;
    ''' &lt;returns&gt;Una cadena JSON envuelta en comillas simples y con las comillas internas escapadas.&lt;/returns&gt;
    Public Function GetJsonValueForSql() As String
        If String.IsNullOrWhiteSpace(JsonContent) OrElse JsonContent.Trim() = "{}" Then
            Return "NULL"
        End If
        Return $"'{JsonContent.Replace("'", "''")}'"
    End Function

    ''' &lt;summary&gt;
    ''' Genera un script T-SQL completo para actualizar múltiples registros en una sola operación.
    ''' &lt;/summary&gt;
    ''' &lt;param name="tableName"&gt;El nombre de la tabla a actualizar.&lt;/param&gt;
    ''' &lt;param name="primaryKeyName"&gt;El nombre de la columna de clave primaria de la tabla.&lt;/param&gt;
    ''' &lt;param name="jsonFieldName"&gt;El nombre del campo JSON a actualizar.&lt;/param&gt;
    ''' &lt;param name="data"&gt;Una colección de objetos. Cada objeto DEBE tener una propiedad con el mismo nombre que 'primaryKeyName' y otra que se serializará como el nuevo contenido JSON.&lt;/param&gt;
    ''' &lt;param name="pkType"&gt;El tipo de dato SQL de la clave primaria (ej: "INT", "UNIQUEIDENTIFIER").&lt;/param&gt;
    ''' &lt;returns&gt;Un script T-SQL para ejecución masiva.&lt;/returns&gt;
    Public Function GenerateBulkUpdateScript(tableName As String, primaryKeyName As String, jsonFieldName As String, data As IEnumerable(Of Object), pkType As String) As String
        Dim jsonData As String = JsonConvert.SerializeObject(data)

        Dim sb As New StringBuilder()
        sb.AppendLine("DECLARE @jsonData NVARCHAR(MAX);")
        sb.AppendLine($"SET @jsonData = '{jsonData.Replace("'", "''")}';")
        sb.AppendLine()
        sb.AppendLine($"UPDATE T")
        sb.AppendLine($"SET T.[{jsonFieldName}] = S.JsonData")
        sb.AppendLine($"FROM [{tableName}] AS T")
        sb.AppendLine($"JOIN (")
        sb.AppendLine($"    SELECT *")
        sb.AppendLine($"    FROM OPENJSON(@jsonData)")
        sb.AppendLine($"    WITH (")
        sb.AppendLine($"        {primaryKeyName} {pkType} '$.{primaryKeyName}',")
        sb.AppendLine($"        JsonData NVARCHAR(MAX) '$' AS JSON")
        sb.AppendLine($"    )")
        sb.AppendLine($") AS S ON T.[{primaryKeyName}] = S.[{primaryKeyName}];")

        Return sb.ToString()
    End Function
#End Region

#Region "Métodos Privados de Ayuda"
    Private Function FormatSqlValue(value As Object) As String
        If value Is Nothing OrElse value Is DBNull.Value Then Return "NULL"

        Select Case value
            Case IsA(Of String), IsA(Of Guid)
                Return $"'{value.ToString().Replace("'", "''")}'"
            Case IsA(Of DateTime)
                Return $"'{DirectCast(value, DateTime):yyyy-MM-ddTHH:mm:ss.fff}'"
            Case IsA(Of Boolean)
                Return value.ToString().ToLower()
            Case Else
                Return value.ToString()
        End Select
    End Function
#End Region

End Class
</code></pre>
        <button class="copy-button">Copiar</button>
        </div>

        <h2>Ejemplos de Uso Avanzado</h2>
        <p>A continuación se muestran ejemplos que cubren las nuevas funcionalidades de la clase.</p>
        
        <h3>1. Trabajar con Objetos y Serialización</h3>
        <div class="code-container">
            <pre><code>
' Creamos una clase o un objeto anónimo
Dim producto = New With {
    .ID = 1025,
    .Nombre = "Teclado Mecánico",
    .Activo = True,
    .Tags = New List(Of String) From {"Gaming", "RGB", " Español"},
    .FechaLanzamiento = New Date(2024, 1, 15)
}

Dim helper As New JsonSqlHelper()
' Serializamos el objeto directamente a la propiedad JsonContent
helper.SetJsonContentFromObject(producto)

Dim jsonForInsert As String = helper.GetJsonValueForSql()
Dim sql As String = $"INSERT INTO Productos (DatosJson) VALUES ({jsonForInsert})"
' Ejecutar el comando SQL...
        </code></pre>
            <button class="copy-button">Copiar</button>
        </div>

        <h3>2. Manipular Arrays</h3>
        <div class="code-container">
            <pre><code>
Dim helper As New JsonSqlHelper()

' Añadir un nuevo tag al final del array 'Tags'
Dim addTagSql As String = helper.AddOrUpdateValue("Productos", "append $.Tags", "Inalámbrico")
' sql resultante: UPDATE Productos SET [DatosJson] = JSON_MODIFY([DatosJson], 'append $.Tags', 'Inalámbrico') WHERE ...

' Eliminar el segundo tag (índice 1) del array
Dim removeTagSql As String = helper.DeleteValue("Productos", "$.Tags[1]")
' sql resultante: UPDATE Productos SET [DatosJson] = JSON_MODIFY([DatosJson], '$.Tags[1]', NULL) WHERE ...
        </code></pre>
            <button class="copy-button">Copiar</button>
        </div>

        <h3>3. Generar Cláusulas WHERE</h3>
        <div class="code-container">
            <pre><code>
Dim helper As New JsonSqlHelper()
helper.SqlServerVersion = SqlServerVersion.SQL2022

' Crear una condición para buscar productos activos
Dim where1 As String = helper.GenerateWhereClause("DatosJson", "$.Activo", "=", True)
' where1: JSON_VALUE([DatosJson], '$.Activo') = true

' Crear una condición para productos lanzados después de una fecha
Dim where2 As String = helper.GenerateWhereClause("DatosJson", "$.FechaLanzamiento", ">", New Date(2023, 12, 31))
' where2: JSON_VALUE([DatosJson], '$.FechaLanzamiento') > '2023-12-31T00:00:00.000'

' Comprobar si la propiedad 'Nombre' existe (aprovechando la optimización de SQL 2022)
Dim where3 As String = helper.GenerateWhereClause("DatosJson", "$.Nombre", "EXISTS", Nothing)
' where3: JSON_PATH_EXISTS([DatosJson], '$.Nombre') = 1

Dim fullSql = $"SELECT * FROM Productos WHERE {where1} AND {where2}"
' Ejecutar el comando SQL...
        </code></pre>
            <button class="copy-button">Copiar</button>
        </div>

        <h3>4. Seleccionar con Tipos de Datos Específicos</h3>
        <div class="code-container">
            <pre><code>
Dim helper As New JsonSqlHelper()
Dim attributesToSelect = New Dictionary(Of String, String) From {
    {"$.Nombre", "NVARCHAR(200)"},
    {"$.Activo", "BIT"},
    {"$.ID", "INT"}
}

Dim selectColumns As String = helper.GetJsonAttributesForSelect("DatosJson", attributesToSelect)
' selectColumns contendrá algo como:
' TRY_CAST(JSON_VALUE([DatosJson], '$.Nombre') AS NVARCHAR(200)) AS Nombre, TRY_CAST(JSON_VALUE([DatosJson], '$.Activo') AS BIT) AS Activo, ...

Dim sql As String = $"SELECT {selectColumns} FROM Productos"
' Ejecutar el comando SQL...
        </code></pre>
            <button class="copy-button">Copiar</button>
        </div>

        <h3>5. Generar Script para Actualización Masiva</h3>
        <div class="code-container">
            <pre><code>
' Creamos una lista de objetos a actualizar. Cada uno tiene la PK y los nuevos datos.
Dim updates = New List(Of Object) From {
    New With {.ProductoID = 1, .Nombre = "Nuevo Nombre 1", .Activo = False},
    New With {.ProductoID = 5, .Nombre = "Otro Nombre", .Activo = True},
    New With {.ProductoID = 12, .Nombre = "Producto Descatalogado", .Activo = False}
}

Dim helper As New JsonSqlHelper()
Dim bulkScript As String = helper.GenerateBulkUpdateScript("Productos", "ProductoID", "DatosJson", updates, "INT")

' bulkScript contendrá el script T-SQL completo para actualizar 3 filas en una sola llamada a la base de datos.
' Simplemente ejecuta este script.
Console.WriteLine(bulkScript)
        </code></pre>
            <button class="copy-button">Copiar</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const allCopyButtons = document.querySelectorAll('.copy-button');

            allCopyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const container = button.parentElement;
                    const pre = container.querySelector('pre');
                    if (pre) {
                        const codeText = pre.innerText;
                        
                        navigator.clipboard.writeText(codeText).then(() => {
                            const originalText = button.innerText;
                            button.innerText = '¡Copiado!';
                            button.classList.add('copied');

                            setTimeout(() => {
                                button.innerText = originalText;
                                button.classList.remove('copied');
                            }, 2000);
                        }).catch(err => {
                            console.error('Error al copiar el texto: ', err);
                            button.innerText = 'Error';
                        });
                    }
                });
            });
        });
    </script>
</body>
</html>
